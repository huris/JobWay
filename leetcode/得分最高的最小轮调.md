#! https://zhuanlan.zhihu.com/p/478044486
## 得分最高的最小轮调

### 题目

[得分最高的最小轮调](https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/)

给你一个数组 `nums`，我们可以将它按一个非负整数 `k` 进行轮调，这样可以使数组变为 `[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]` 的形式。此后，任何值小于或等于其索引的项都可以记作一分。

例如，数组为 `nums = [2,4,1,3,0]`，我们按 `k = 2` 进行轮调后，它将变成 `[1,3,0,2,4]`。这将记为 `3` 分，因为 `1 > 0` [不计分]、`3 > 1` [不计分]、`0 <= 2` [计 1 分]、`2 <= 3` [计 1 分]，`4 <= 4` [计 1 分]。

在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 `k` 。如果有多个答案，返回满足条件的最小的下标 `k` 。

**提示：**

- `1 <= nums.length <= 105`
- `0 <= nums[i] < nums.length`

### 示例

>输入：nums = [2,3,1,4,0]
>输出：3
>解释：
>下面列出了每个 k 的得分：
>k = 0,  nums = [2,3,1,4,0],    score 2
>k = 1,  nums = [3,1,4,0,2],    score 3
>k = 2,  nums = [1,4,0,2,3],    score 3
>k = 3,  nums = [4,0,2,3,1],    score 4
>k = 4,  nums = [0,2,3,1,4],    score 3
>所以我们应当选择 k = 3，得分最高。

>输入：nums = [1,3,0,2,4]
>输出：0
>解释：
>nums 无论怎么变化总是有 3 分。
>所以我们将选择最小的 k，即 0。

### 代码

以`nums=[2, 3, 1, 4, 0]`进行分析：

- `nums[0]=2`移动到`2`号索引位置`[4, 0, 2, 3, 1]`其对应的`k`为`3=(0-nums[0]+5)%5`
- `nums[1]=3`移动到`3`号索引位置`[0, 2, 3, 1, 4]`其对应的`k`为`3=(1-nums[1]+5)%5`
- `nums[2]=1`移动到`1`号索引位置`[3, 1, 4, 0, 2]`其对应的`k`为`1=(2-nums[2]+5)%5`
- `nums[3]=4`移动到`4`号索引位置`[0, 2, 3, 1, 4]`其对应的`k`为`1=(3-nums[3]+5)%5`
- `nums[4]=0`移动到`0`号索引位置`[0, 2, 3, 1, 4]`其对应的`k`为`3=(4-nums[4]+5)%5`

即，将`nums[i]`向左移动到下标`nums[nums[i]]`的位置需要`k=(i-nums[i]+N)%N`。

可以发现，`nums[nums[i]]`是`nums[i]`第一个能得分的位置，之后增大`k`（向左移），`nums[i]`可以继续得分。

如果把`nums[nums[i]]`移动到`nums[i]`后，先让它再移动`1`（表示此时`nums[i]`刚好不得分），记录所有的`mk[i]=(i-nums[i]+1+n)%n`，此时`mk[i]`记录`k=i`时，不得分的元素个数。

之后对所有`n`次移动进行判断，若`k=k`时，`nums[i]`刚好不得分，则`k=k+1`时，`nums[i]`继续不得分，但是`nums[0]`开始得分。

递推公式：`mk[i] += mk[i - 1] - 1`

```c++
class Solution {
public:
    int bestRotation(vector<int>& nums) {
        int re = 0, n = nums.size();
        vector<int>mk(n, 0);
        
        for(int i = 0; i < n; ++i){
            mk[(i - nums[i] + 1 + n) % n] += 1;
        }

        for(int i = 1; i < n; ++i){
            mk[i] += mk[i - 1] - 1;
            if(mk[i] < mk[re]){
                re = i;
            }
        }
        return re;
    }
};
```

